# 模板方法模式
模板方法模式在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

- 抽象模板(Abstract Template)角色：
定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。  
定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。
顶级逻辑也有可能调用一些具体方法。  

- 具体模板(Concrete Template)角色又如下责任：
实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。  
每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。

模板模式的关键是：**子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。**  
每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。

# 适用场景
- 在某些类的算法中，用了相同的方法，造成代码的重复。
- 控制子类扩展，子类必须遵守算法规则。

# 优缺点
优点:  
- 模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。
- 子类实现算法的某些细节，有助于算法的扩展。
- 通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。

缺点
- 每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。

# 设计原则
- 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。
